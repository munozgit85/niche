"use strict";
var ParamHandler_1 = require("./ParamHandler");
var MetadataBuilder_1 = require("./metadata-builder/MetadataBuilder");
var PromiseUtils_1 = require("./util/PromiseUtils");
/**
 * Registers controllers and actions in the given server framework.
 */
var RoutingControllerExecutor = (function () {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    function RoutingControllerExecutor(driver) {
        this.driver = driver;
        this.paramHandler = new ParamHandler_1.ParamHandler(driver);
        this.metadataBuilder = new MetadataBuilder_1.MetadataBuilder();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    RoutingControllerExecutor.prototype.bootstrap = function () {
        this.driver.bootstrap();
        return this;
    };
    /**
     * Registers actions in the driver.
     */
    RoutingControllerExecutor.prototype.registerActions = function (classes) {
        var _this = this;
        var middlewares = this.metadataBuilder.buildMiddlewareMetadata(classes);
        var interceptors = this.metadataBuilder.buildInterceptorMetadata(classes);
        var controllers = this.metadataBuilder.buildControllerMetadata(classes);
        controllers.forEach(function (controller) {
            controller.actions.forEach(function (action) {
                _this.driver.registerAction(action, middlewares, interceptors, function (options) {
                    _this.handleAction(action, options);
                });
            });
        });
        this.driver.registerRoutes();
        return this;
    };
    /**
     * Registers post-execution middlewares in the driver.
     */
    RoutingControllerExecutor.prototype.registerMiddlewares = function (afterAction, classes) {
        var _this = this;
        this.metadataBuilder
            .buildMiddlewareMetadata(classes)
            .filter(function (middleware) { return middleware.isGlobal && middleware.afterAction === afterAction; })
            .sort(function (middleware1, middleware2) { return middleware1.priority - middleware2.priority; })
            .reverse()
            .forEach(function (middleware) {
            if (middleware.isErrorHandler) {
                _this.driver.registerErrorHandler(middleware);
            }
            else if (middleware.isUseMiddleware) {
                _this.driver.registerMiddleware(middleware);
            }
        });
        return this;
    };
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    RoutingControllerExecutor.prototype.handleAction = function (action, options) {
        var _this = this;
        // compute all parameters
        var paramsPromises = action.params
            .sort(function (param1, param2) { return param1.index - param2.index; })
            .map(function (param) { return _this.paramHandler.handleParam(options, param); });
        // after all parameters are computed
        Promise.all(paramsPromises).then(function (params) {
            // execute action and handle result
            var result = action.executeAction(params);
            // if (result !== undefined)
            _this.handleResult(result, action, options);
        }).catch(function (error) {
            _this.driver.handleError(error, action, options);
        });
    };
    RoutingControllerExecutor.prototype.handleResult = function (result, action, options) {
        var _this = this;
        if (PromiseUtils_1.PromiseUtils.isPromiseLike(result)) {
            result
                .then(function (data) {
                return _this.handleResult(data, action, options);
            })
                .catch(function (error) {
                _this.driver.handleError(error, action, options);
            });
        }
        else {
            if (options.useInterceptorFunctions) {
                var awaitPromise = PromiseUtils_1.PromiseUtils.runInSequence(options.useInterceptorFunctions, function (interceptorFn) {
                    var interceptedResult = interceptorFn(options.request, options.response, result);
                    if (interceptedResult instanceof Promise) {
                        return interceptedResult.then(function (resultFromPromise) {
                            result = resultFromPromise;
                        });
                    }
                    else {
                        result = interceptedResult;
                        return Promise.resolve();
                    }
                });
                awaitPromise
                    .then(function () { return _this.driver.handleSuccess(result, action, options); })
                    .catch(function (error) { return _this.driver.handleError(error, action, options); });
            }
            else {
                this.driver.handleSuccess(result, action, options);
            }
        }
    };
    return RoutingControllerExecutor;
}());
exports.RoutingControllerExecutor = RoutingControllerExecutor;

//# sourceMappingURL=RoutingControllerExecutor.js.map
