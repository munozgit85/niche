"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BadHttpActionError_1 = require("../error/BadHttpActionError");
var ParamTypes_1 = require("../metadata/types/ParamTypes");
var ActionMetadata_1 = require("../metadata/ActionMetadata");
var class_transformer_1 = require("class-transformer");
var BaseDriver_1 = require("./BaseDriver");
var cookie = require("cookie");
/**
 * Base driver functionality for all other drivers.
 */
var ExpressDriver = (function (_super) {
    __extends(ExpressDriver, _super);
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    function ExpressDriver(express) {
        var _this = _super.call(this) || this;
        _this.express = express;
        if (require) {
            if (!express) {
                try {
                    _this.express = require("express")();
                }
                catch (e) {
                    throw new Error("express package was not found installed. Try to install it: npm install express --save");
                }
            }
        }
        else {
            throw new Error("Cannot load express. Try to install all required dependencies.");
        }
        return _this;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    ExpressDriver.prototype.bootstrap = function () {
    };
    /**
     * Registers given error handler in the driver.
     */
    ExpressDriver.prototype.registerErrorHandler = function (middleware) {
        if (!middleware.errorHandlerInstance.error)
            return;
        this.express.use(function (error, request, response, next) {
            middleware.errorHandlerInstance.error(error, request, response, next);
        });
    };
    /**
     * Registers middleware that run before controller actions.
     */
    ExpressDriver.prototype.registerMiddleware = function (middleware) {
        var _this = this;
        if (!middleware.instance.use)
            return;
        this.express.use(function (request, response, next) {
            try {
                var useResult = middleware.instance.use(request, response, next);
                if (useResult instanceof Promise) {
                    useResult.catch(function (error) {
                        _this.handleError(error, undefined, {
                            request: request,
                            response: response,
                            next: next,
                        });
                    });
                }
            }
            catch (error) {
                _this.handleError(error, undefined, {
                    request: request,
                    response: response,
                    next: next,
                });
            }
        });
    };
    /**
     * Registers action in the driver.
     */
    ExpressDriver.prototype.registerAction = function (action, middlewares, interceptors, executeCallback) {
        var expressAction = action.type.toLowerCase();
        if (!this.express[expressAction])
            throw new BadHttpActionError_1.BadHttpActionError(action.type);
        var useInterceptors = action.controllerMetadata.useInterceptors.concat(action.useInterceptors);
        var useInterceptorFunctions = this.registerIntercepts(useInterceptors, interceptors);
        var globalUseInterceptors = interceptors
            .filter(function (interceptor) { return interceptor.isGlobal; })
            .sort(function (interceptor1, interceptor2) { return interceptor1.priority - interceptor2.priority; })
            .reverse()
            .map(function (interceptor) {
            return function (request, response, result) {
                return interceptor.instance.intercept(request, response, result);
            };
        });
        var routeHandler = function RouteHandler(request, response, next) {
            var options = {
                request: request,
                response: response,
                next: next,
                useInterceptorFunctions: globalUseInterceptors.concat(useInterceptorFunctions)
            };
            executeCallback(options);
        };
        var defaultMiddlewares = [];
        if (action.isBodyUsed) {
            if (action.isJsonTyped) {
                defaultMiddlewares.push(this.loadBodyParser().json());
            }
            else {
                defaultMiddlewares.push(this.loadBodyParser().text());
            }
        }
        if (action.isFileUsed || action.isFilesUsed) {
            var multer_1 = this.loadMulter();
            action.params
                .filter(function (param) { return param.type === ParamTypes_1.ParamTypes.UPLOADED_FILE; })
                .forEach(function (param) {
                defaultMiddlewares.push(multer_1(param.extraOptions).single(param.name));
            });
            action.params
                .filter(function (param) { return param.type === ParamTypes_1.ParamTypes.UPLOADED_FILES; })
                .forEach(function (param) {
                defaultMiddlewares.push(multer_1(param.extraOptions).array(param.name));
            });
        }
        var uses = action.controllerMetadata.uses.concat(action.uses);
        var fullRoute = action.fullRoute instanceof RegExp
            ? ActionMetadata_1.ActionMetadata.appendBaseRouteToRegexpRoute(action.fullRoute, this.routePrefix)
            : "" + this.routePrefix + action.fullRoute;
        var preMiddlewareFunctions = this.registerUses(uses.filter(function (use) { return !use.afterAction; }), middlewares);
        var postMiddlewareFunctions = this.registerUses(uses.filter(function (use) { return use.afterAction; }), middlewares);
        var expressParams = [fullRoute].concat(preMiddlewareFunctions, defaultMiddlewares, [routeHandler], postMiddlewareFunctions);
        // finally register action
        (_a = this.express)[expressAction].apply(_a, expressParams);
        var _a;
    };
    ExpressDriver.prototype.registerRoutes = function () {
    };
    /**
     * Gets param from the request.
     */
    ExpressDriver.prototype.getParamFromRequest = function (actionOptions, param) {
        var request = actionOptions.request;
        switch (param.type) {
            case ParamTypes_1.ParamTypes.BODY:
                return request.body;
            case ParamTypes_1.ParamTypes.PARAM:
                return request.params[param.name];
            case ParamTypes_1.ParamTypes.SESSION:
                if (param.name) {
                    return request.session[param.name];
                }
                else {
                    return request.session;
                }
            case ParamTypes_1.ParamTypes.QUERY:
                return request.query[param.name];
            case ParamTypes_1.ParamTypes.HEADER:
                return request.headers[param.name.toLowerCase()];
            case ParamTypes_1.ParamTypes.UPLOADED_FILE:
                return request.file;
            case ParamTypes_1.ParamTypes.UPLOADED_FILES:
                return request.files;
            case ParamTypes_1.ParamTypes.BODY_PARAM:
                return request.body[param.name];
            case ParamTypes_1.ParamTypes.COOKIE:
                if (!request.headers.cookie)
                    return;
                var cookies = cookie.parse(request.headers.cookie);
                return cookies[param.name];
        }
    };
    /**
     * Defines an algorithm of how to handle success result of executing controller action.
     */
    ExpressDriver.prototype.handleSuccess = function (result, action, options) {
        if (this.useClassTransformer && result && result instanceof Object) {
            var options_1 = action.responseClassTransformOptions || this.classToPlainTransformOptions;
            result = class_transformer_1.classToPlain(result, options_1);
        }
        var response = options.response;
        var isResultUndefined = result === undefined;
        var isResultNull = result === null;
        var isResultEmpty = isResultUndefined || isResultNull || result === false || result === "";
        // set http status
        if (action.undefinedResultCode && isResultUndefined) {
            response.status(action.undefinedResultCode);
        }
        else if (action.nullResultCode && isResultNull) {
            response.status(action.nullResultCode);
        }
        else if (action.emptyResultCode && isResultEmpty) {
            response.status(action.emptyResultCode);
        }
        else if (action.successHttpCode) {
            response.status(action.successHttpCode);
        }
        // apply http headers
        Object.keys(action.headers).forEach(function (name) {
            response.header(name, action.headers[name]);
        });
        if (action.redirect) {
            response.redirect(action.redirect);
            options.next();
        }
        else if (action.renderedTemplate) {
            var renderOptions = result && result instanceof Object ? result : {};
            this.express.render(action.renderedTemplate, renderOptions, function (err, html) {
                if (err && action.isJsonTyped) {
                    // response.json(err);
                    return options.next(err);
                }
                else if (err && !action.isJsonTyped) {
                    // response.send(err);
                    return options.next(err);
                }
                else if (html) {
                    response.send(html);
                }
                options.next();
            });
        }
        else if (result !== undefined || action.undefinedResultCode) {
            if (result === null || (result === undefined && action.undefinedResultCode)) {
                if (result === null && !action.nullResultCode && !action.emptyResultCode) {
                    response.status(204);
                }
                if (action.isJsonTyped) {
                    response.json();
                }
                else {
                    response.send();
                }
                options.next();
            }
            else {
                if (action.isJsonTyped) {
                    response.json(result);
                }
                else {
                    response.send(String(result));
                }
                options.next();
            }
        }
        else {
            options.next();
        }
    };
    /**
     * Defines an algorithm of how to handle error during executing controller action.
     */
    ExpressDriver.prototype.handleError = function (error, action, options) {
        if (this.isDefaultErrorHandlingEnabled) {
            var response_1 = options.response;
            // set http code
            // note that we can't use error instanceof HttpError properly anymore because of new typescript emit process
            if (error.httpCode) {
                response_1.status(error.httpCode);
            }
            else {
                response_1.status(500);
            }
            // apply http headers
            Object.keys(action.headers).forEach(function (name) {
                response_1.header(name, action.headers[name]);
            });
            // send error content
            if (action.isJsonTyped) {
                response_1.json(this.processJsonError(error));
            }
            else {
                response_1.send(this.processTextError(error)); // todo: no need to do it because express by default does it
            }
        }
        options.next(error);
    };
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    ExpressDriver.prototype.registerIntercepts = function (useInterceptors, interceptors) {
        var interceptFunctions = [];
        useInterceptors.forEach(function (useInterceptor) {
            if (useInterceptor.interceptor.prototype && useInterceptor.interceptor.prototype.intercept) {
                interceptors.forEach(function (interceptor) {
                    if (interceptor.instance instanceof useInterceptor.interceptor) {
                        interceptFunctions.push(function (request, response, result) {
                            return interceptor.instance.intercept(request, response, result);
                        });
                    }
                });
            }
            else {
                interceptFunctions.push(useInterceptor.interceptor);
            }
        });
        return interceptFunctions;
    };
    ExpressDriver.prototype.registerUses = function (uses, middlewares) {
        var middlewareFunctions = [];
        uses.forEach(function (use) {
            if (use.middleware.prototype && use.middleware.prototype.use) {
                middlewares.forEach(function (middleware) {
                    if (middleware.instance instanceof use.middleware) {
                        middlewareFunctions.push(function (request, response, next) {
                            return middleware.instance.use(request, response, next);
                        });
                    }
                });
            }
            else if (use.middleware.prototype && use.middleware.prototype.error) {
                middlewares.forEach(function (middleware) {
                    if (middleware.errorHandlerInstance instanceof use.middleware) {
                        middlewareFunctions.push(function (error, request, response, next) {
                            return middleware.errorHandlerInstance.error(error, request, response, next);
                        });
                    }
                });
            }
            else {
                middlewareFunctions.push(use.middleware);
            }
        });
        return middlewareFunctions;
    };
    ExpressDriver.prototype.loadBodyParser = function () {
        try {
            return require("body-parser");
        }
        catch (e) {
            throw new Error("body-parser package was not found installed. Try to install it: npm install body-parser --save");
        }
    };
    ExpressDriver.prototype.loadMulter = function () {
        try {
            return require("multer");
        }
        catch (e) {
            throw new Error("multer package was not found installed. Try to install it: npm install multer --save");
        }
    };
    return ExpressDriver;
}(BaseDriver_1.BaseDriver));
exports.ExpressDriver = ExpressDriver;

//# sourceMappingURL=ExpressDriver.js.map
