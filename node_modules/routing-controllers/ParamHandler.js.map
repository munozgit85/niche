{"version":3,"sources":["../../src/ParamHandler.ts"],"names":[],"mappings":"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","file":"ParamHandler.js","sourcesContent":["import {ParameterParseJsonError} from \"./error/ParameterParseJsonError\";\nimport {plainToClass} from \"class-transformer\";\nimport {ParamTypes} from \"./metadata/types/ParamTypes\";\nimport {ParamMetadata} from \"./metadata/ParamMetadata\";\nimport {ActionCallbackOptions} from \"./ActionCallbackOptions\";\nimport {Driver} from \"./driver/Driver\";\n\n/**\n * Helps to handle parameters.\n */\nexport class ParamHandler {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private driver: Driver) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    handleParam(actionOptions: ActionCallbackOptions, param: ParamMetadata): Promise<any> {\n\n        const request = actionOptions.request;\n        const response = actionOptions.response;\n        \n        if (param.type === ParamTypes.REQUEST)\n            return Promise.resolve(request);\n\n        if (param.type === ParamTypes.RESPONSE)\n            return Promise.resolve(response);\n        \n        let value: any, originalValue: any;\n        value = originalValue = this.driver.getParamFromRequest(actionOptions, param);\n        \n        const isValueEmpty = value === null || value === undefined || value === \"\";\n        const isValueEmptyObject = value instanceof Object && Object.keys(value).length === 0;\n\n        if (!isValueEmpty)\n            value = this.handleParamFormat(value, param);\n        \n        // check cases when parameter is required but its empty and throw errors in such cases\n        if (param.isRequired) {\n            // todo: make better error messages here\n            if (param.name && isValueEmpty) {\n                return Promise.reject(\"Parameter \" + param.name + \" is required for request on \" + request.method + \" \" + request.url);\n\n            } else if (!param.name && (isValueEmpty || isValueEmptyObject)) {\n                return Promise.reject(\"Request body is required for request on \" + request.method + \" \" + request.url);\n            }\n        }\n\n        // if transform function is given for this param then apply it\n        if (param.transform)\n            value = param.transform(value, request, response);\n        \n        const promiseValue = value instanceof Promise ? value : Promise.resolve(value);\n        return promiseValue.then((value: any) => {\n\n            if (param.isRequired && originalValue !== null && originalValue !== undefined && isValueEmpty) {\n                // TODO: handleResultOptions.errorHttpCode = 404; // maybe throw ErrorNotFoundError here?\n                const contentType = param.reflectedType && param.reflectedType.name ? param.reflectedType.name : \"content\";\n                const message = param.name ? ` with ${param.name}='${originalValue}'` : ``;\n                return Promise.reject(`Requested ${contentType + message} was not found`);\n            }\n\n            return value;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private handleParamFormat(value: any, param: ParamMetadata): any {\n        const format = param.format;\n        const formatName = format instanceof Function && format.name ? format.name : format instanceof String ? format : \"\";\n        switch (formatName.toLowerCase()) {\n            case \"number\":\n                return +value;\n\n            case \"string\":\n                return value;\n\n            case \"boolean\":\n                if (value === \"true\") {\n                    return true;\n                    \n                } else if (value === \"false\") {\n                    return false;\n                }\n                return !!value;\n\n            default:\n                const isObjectFormat = format instanceof Function || formatName.toLowerCase() === \"object\";\n                if (value && (param.parseJson || isObjectFormat))\n                    value = this.parseValue(value, param);\n        }\n        return value;\n    }\n\n    private parseValue(value: any, paramMetadata: ParamMetadata) {\n        try {\n            const parseValue = typeof value === \"string\" ? JSON.parse(value) : value;\n            if (paramMetadata.format !== Object && paramMetadata.format && this.driver.useClassTransformer) {\n                const options = paramMetadata.classTransformOptions || this.driver.plainToClassTransformOptions;\n                return plainToClass(paramMetadata.format, parseValue, options);\n            } else {\n                return parseValue;\n            }\n        } catch (er) {\n            // console.log(er);\n            throw new ParameterParseJsonError(paramMetadata.name, value);\n        }\n    }\n\n\n}"],"sourceRoot":"."}